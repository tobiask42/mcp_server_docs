- Frage an Chat-GPT nach MÃ¶glichkeiten Webcrawling durchzufÃ¼hren -> Scrapy
- Teils Nutzung von Chatbot fÃ¼r Implementierung
- Chunking Ã¼ber einfache Pythoninterne Funktionen
- Frage an Chat-GPT nach Vektordatenbanke -> ChromaDB
- Orientierung an Doku, Bessere Strukturierung von eigenem Code durch ChatbotunterstÃ¼tzung
- mcp-Umsetzung durch mix aus Chatbot und Doku
- Eigener Chatbot komplett KI-Generiert
- Der Prototyp wurde mit der FastAPI Dokumentation getestet

âœ… Chunking ready for RAG â€“ Checkliste

Zeichen/Tokens im Blick

ZielgrÃ¶ÃŸe: ~200â€“400 Tokens (â‰ˆ 800â€“1600 Zeichen).

Sicherstellen, dass kein Chunk lÃ¤nger ist als das Tokenlimit des Embedding-Modells (MiniLM: 512, BGE/E5: 1024).

Overlap

10â€“20 % Ãœberlappung einbauen, um ÃœbergÃ¤nge nicht zu verlieren.

Besonders nÃ¼tzlich bei FlieÃŸtext + Code-Beispielen.

CodeblÃ¶cke schÃ¼tzen

Fenced Code (â€žâ€¦â€œ) als unteilbare Einheiten behandeln.

Bei sehr langen CodeblÃ¶cken â†’ separater Chunk + kurzer Kontext davor.

Heading-basierte Splits

Split nach H2â€“H5 statt nur H2.

Heading-Pfad (H1 â†’ H2 â†’ H3 â€¦) als Metadatum abspeichern.

Boilerplate entfernen

Navigation, Footer, â€žSkip to contentâ€œ, â€žEdit on GitHubâ€œ rausfiltern.

Stabile IDs

Chunk-ID deterministisch: (url + heading + chunk_index).

Keine LÃ¤ngenabhÃ¤ngigkeit, damit Re-Crawls stabil bleiben.

Metadaten speichern

Immer mitgeben: URL, Titel, heading-Pfad, chunk_index, n_chars, crawl_timestamp.

So kannst du spÃ¤ter zitieren, filtern und Debugging betreiben.

DiversitÃ¤t sichern

Beim Kontextaufbau nicht nur Chunks von derselben Seite nehmen.

Maximal n Chunks pro URL im finalen Prompt.

Eval-Set vorbereiten

30â€“40 Fragen definieren, erwartete Seiten/Abschnitte notieren.

Chunking-Varianten gegeneinander testen (Recall@k, nDCG).

Dokumentieren

In der Abgabe explizit auf Chunking-Parameter eingehen (z. B. â€ž1000 Zeichen, 100 Overlapâ€œ).

Trade-offs benennen: IndexgrÃ¶ÃŸe vs. Kontexttreue.

ðŸ“‹ FastAPI Eval-Fragen (35 StÃ¼ck)
Grundlagen (5)

Wie definiere ich meinen ersten FastAPI-Endpoint mit @app.get?

Wie starte ich einen FastAPI-Server mit uvicorn?

Wie dokumentiert FastAPI automatisch meine API (Swagger UI)?

Was ist der Unterschied zwischen @app.get und @app.post?

Wie gebe ich eine einfache JSON-Antwort zurÃ¼ck?

Path & Query Parameters (5)

Wie definiere ich Path-Parameter mit Typkonvertierung?

Wie setze ich Default-Werte fÃ¼r Query-Parameter?

Wie validiere ich Query-Parameter mit regulÃ¤ren AusdrÃ¼cken?

Wie nutze ich Path() und Query() fÃ¼r zusÃ¤tzliche Metadaten?

Wie gebe ich optionale Query-Parameter an?

Request Body & Pydantic Models (5)

Wie erstelle ich ein Request-Model mit Pydantic?

Wie definiere ich optionale Felder in einem Model?

Wie nutze ich verschachtelte Models (nested models)?

Wie validiere ich Listen-Felder (list[str])?

Wie Ã¼berschreibe ich Standardwerte in Pydantic-Feldern?

Response Handling (4)

Wie setze ich den HTTP-Statuscode einer Antwort?

Wie definiere ich ein response_model?

Wie filtere ich Felder im response_model (exclude, include)?

Wie sende ich eine StreamingResponse zurÃ¼ck?

Dependencies (4)

Wie definiere ich eine Dependency mit Depends()?

Wie gebe ich eine Datenbank-Session als Dependency weiter?

Wie nutze ich Sub-Dependencies?

Wie validiere ich einen API-Key per Dependency?

Error Handling & Exceptions (3)

Wie werfe ich eine HTTPException mit Statuscode und Detail?

Wie definiere ich einen globalen Exception Handler?

Wie Ã¼berschreibe ich die Validation Errors von Pydantic?

Advanced Features (5)

Wie setze ich Background Tasks mit BackgroundTasks ein?

Wie implementiere ich WebSockets in FastAPI?

Wie fÃ¼ge ich Middleware hinzu (z. B. Logging oder CORS)?

Wie konfiguriere ich CORS-Einstellungen?

Wie nutze ich Depends fÃ¼r Security (OAuth2, JWT)?

Deployment & Performance (4)

Wie starte ich FastAPI im Produktionsmodus mit Uvicorn/Gunicorn?

Wie aktiviere ich Autoreload im Entwicklungsmodus?

Wie skaliere ich FastAPI-Apps mit mehreren Prozessen/Workern?

Wie nutze ich FastAPI mit Docker?

ðŸ“‹ FastAPI Eval Questions (English, 35)
Basics (5)

How do I define my first FastAPI endpoint with @app.get?

How do I start a FastAPI server with uvicorn?

How does FastAPI automatically document my API (Swagger UI)?

What is the difference between @app.get and @app.post?

How do I return a simple JSON response?

Path & Query Parameters (5)

How do I define path parameters with type conversion?

How do I set default values for query parameters?

How do I validate query parameters with regular expressions?

How do I use Path() and Query() for additional metadata?

How do I declare optional query parameters?

Request Body & Pydantic Models (5)

How do I create a request model with Pydantic?

How do I define optional fields in a model?

How do I use nested Pydantic models?

How do I validate list fields (e.g., list[str])?

How do I override default values in Pydantic fields?

Response Handling (4)

How do I set the HTTP status code of a response?

How do I define a response_model?

How do I filter fields in a response_model (exclude, include)?

How do I return a StreamingResponse?

Dependencies (4)

How do I define a dependency with Depends()?

How do I provide a database session as a dependency?

How do I use sub-dependencies?

How do I validate an API key using a dependency?

Error Handling & Exceptions (3)

How do I raise an HTTPException with status code and detail?

How do I define a global exception handler?

How do I override Pydanticâ€™s validation errors?

Advanced Features (5)

How do I use background tasks with BackgroundTasks?

How do I implement WebSockets in FastAPI?

How do I add middleware (e.g., logging or CORS)?

How do I configure CORS settings?

How do I use Depends for security (OAuth2, JWT)?

Deployment & Performance (4)

How do I run FastAPI in production with Uvicorn/Gunicorn?

How do I enable autoreload in development mode?

How do I scale FastAPI apps with multiple processes/workers?

How do I use FastAPI with Docker?



Was sind sinnvolle Parameter fÃ¼r ein RAG?

[Schlussfolgerung] Basierend auf verbreiteten Heuristiken und beobachteten Mustern in RAG-Pipelines (nicht projektspezifisch verifiziert).

Kurzantwort (konkrete Richtwerte & warum):

Chunking

CHUNK_MAX_CHARS: 800â€“1 200. Ihr Wert 1000 ist gut.

CHUNK_OVERLAP: 10â€“15 % der Chunk-LÃ¤nge â‡’ 100â€“150 bei 1000 Zeichen ist passend.

[Schlussfolgerung] Falls viele Code-/API-Signaturen: eher 600â€“800 und satz-/Ã¼berschriftsbewusst splitten (kein Hard-Wrap mitten in Headern/Listen).

Retrieval & Kontextbudget

RAG_MAX_CHUNKS_PER_URL: 1 ist meist zu strikt. 3â€“5 reduziert â€žSingle-Source-Biasâ€œ.

RAG_MAX_CONTEXT_CHARS: an das Tokenfenster koppeln. FÃ¼r OLLAMA_CONTEXT_WINDOW_TOKENS=4096:

[Schlussfolgerung] ~60â€“70 % fÃ¼rs Kontextfenster reservieren â†’ ca. 2 600 Tokens Kontext.

Grobe Umrechnung 1 Token â‰ˆ 3.5â€“4 Zeichen â‡’ ~9â€“10.5 k Zeichen.

Empfehlung: 8 000â€“10 000 statt 5 000.

Fehlt in Ihrer Config (empfohlen hinzunehmen):

RAG_TOP_K: 6â€“8 (Startwert).

RAG_PER_SOURCE_CAP: 2â€“3 (max. Chunks pro URL/Quelle).

RAG_MIN_SIMILARITY: weiches Filter (z. B. 0.2â€“0.3 Cosine) ODER per Perzentil schneiden (z. B. oberstes 20â€“30 %).

[Schlussfolgerung] Optional: Cross-Encoder-Reranker nach dem Vektor-Retrieval (z. B. top-20 â†’ reranke â†’ top-6).

LLM-AntwortlÃ¤nge & Sampling

OLLAMA_MAX_TOKENS: 384 ist knapp; 512â€“768 gibt dem Modell Luft fÃ¼r knappe BegrÃ¼ndungen ohne Abschneiden.

OLLAMA_TEMPERATURE: 0.0 ist gut fÃ¼r Fakten; 0.1â€“0.2 kann bei â€žzusammenfassen & prÃ¤zisierenâ€œ helfen.

SYSTEM_PROMPT: gut. ErgÃ¤nzen Sie ggf.:

â€žWenn mehrere relevante Stellen existieren, fasse zusammen und nenne die betreffenden Abschnitte (ohne URLs).â€œ

â€žWenn Kontext widersprÃ¼chlich ist, sage das explizit.â€œ

Embeddings (fehlt in Ihrer Datei, aber zentral)

[Schlussfolgerung] FÃ¼gen Sie explizite Settings hinzu, z. B.:

EMBEDDING_MODEL (z. B. nomic-embed-text, bge-small-en, all-MiniLM-L6-v2)

EMBEDDING_DIM (abhÃ¤ngig vom Modell)

EMBEDDING_NORMALIZE: True (Cosine-Vergleich)

EMBEDDING_BATCH_SIZE: 128â€“512 (GPU/CPU abhÃ¤ngig)

Einheitliche Preprocessing-Pipeline (Kleinbuchstaben, Unicode-NFKC, StoppwÃ¶rter nur wenn nÃ¶tig; Code nicht lowercasen).

Chroma / Indexierung

CHROMA_BATCH_SIZE: 1000 ist ok; bei knapper RAM/GPU 256â€“512.

CHROMA_REMOVE_OLD: False fÃ¼r inkrementelles Crawlen; setzen Sie einen â€ždataset_idâ€œ/â€žcorpus_versionâ€œ-Filter, um AltstÃ¤nde gezielt zu lÃ¶schen.

[Schlussfolgerung] Persistente Metadata: url, section, hpath, version, lang, hash; Retrieval spÃ¤ter besser steuerbar (z. B. Boost fÃ¼r section in ["tutorial","reference"]).

Crawler

Ihre Defaults sind konservativ. FÃ¼r schnellere LÃ¤ufe: SPIDER_CONCURRENT_REQUESTS=16, SPIDER_DOWNLOAD_DELAY=0.1 (nur wenn Server es erlaubt).

EMAIL als UA-Kontakt ist gut; ergÃ¤nzen Sie User-Agent klar mit Projektname/URL.

Prompts

NO_CONTEXT_PROMPT / CONTEXT_PROMPT sind streng, das ist gut. FÃ¼gen Sie ein Format-GerÃ¼st hinzu:

â€žWenn nicht im Kontext: â€ºIch kann das nicht verifizieren.â€¹â€œ (haben Sie bereits)

â€žAntworte in 3â€“6 SÃ¤tzen, keine URLs, nenne relevante Abschnitte/Ãœberschriften.â€œ